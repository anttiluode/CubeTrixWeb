<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CubeTrix - HTML5</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background-color: #000;
      color: #fff;
    }
    #gameContainer {
      position: relative;
      width: 100%;
      height: 100vh;
    }
    #gameCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #uiContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    #healthBar {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 200px;
      height: 20px;
      background-color: #333;
      border: 2px solid #fff;
    }
    #healthFill {
      width: 100%;
      height: 100%;
      background-color: #3c3;
    }
    #armorBar {
      position: absolute;
      bottom: 50px;
      left: 20px;
      width: 200px;
      height: 20px;
      background-color: #333;
      border: 2px solid #fff;
    }
    #armorFill {
      width: 100%;
      height: 100%;
      background-color: #39f;
    }
    #score {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 24px;
      text-shadow: 2px 2px 2px #000;
    }
    #quote {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      text-align: center;
      text-shadow: 2px 2px 2px #000;
      opacity: 0;
      transition: opacity 0.5s;
      width: 80%;
      max-width: 800px;
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      pointer-events: none;
    }
    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background-color: #fff;
    }
    #crosshair::before {
      width: 2px;
      height: 20px;
      left: 9px;
      top: 0;
    }
    #crosshair::after {
      width: 20px;
      height: 2px;
      left: 0;
      top: 9px;
    }
    #mainMenu, #gameOverMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      max-width: 400px;
      background-color: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      border: 2px solid #39f;
      text-align: center;
      pointer-events: auto;
    }
    #mainMenu h1,
    #gameOverMenu h1 {
      color: #f33;
      font-size: 48px;
      margin-top: 0;
      text-shadow: 2px 2px 2px #000;
    }
    .menuButton {
      display: block;
      width: 200px;
      margin: 10px auto;
      padding: 10px;
      background-color: #39f;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-size: 18px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .menuButton:hover {
      background-color: #27c;
    }
    #gameOverMenu {
      display: none;
    }
    #helpMenu {
      display: none;
      padding: 30px;
    }
    #helpMenu h2 {
      margin-top: 0;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="uiContainer">
      <div id="healthBar"><div id="healthFill"></div></div>
      <div id="armorBar"><div id="armorFill"></div></div>
      <div id="score">Score: 0</div>
      <div id="quote"></div>
      <div id="crosshair"></div>
      <div id="mainMenu">
        <h1>CUBETRIX</h1>
        <button id="startButton" class="menuButton">Start Game</button>
        <button id="helpButton" class="menuButton">Help</button>
        <button id="soundButton" class="menuButton">Sound: ON</button>
        <button id="speechButton" class="menuButton">Speech: ON</button>
        <div id="helpMenu">
          <h2>How to Play</h2>
          <p>
            <strong>Controls:</strong><br>
            WASD - Move<br>
            SPACE - Jump<br>
            SHIFT - Run<br>
            Left Click - Shoot
          </p>
          <p>
            <strong>Tips:</strong><br>
            - Shoot health pills and armor pickups to collect them<br>
            - Red cubes can't reach snowy peaks<br>
            - Collect green health pills and blue armor<br>
            - Use high ground to your advantage<br>
            - Keep moving to survive longer
          </p>
          <button id="backButton" class="menuButton">Back</button>
        </div>
      </div>
      <div id="gameOverMenu">
        <h1>GAME OVER</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restartButton" class="menuButton">Play Again</button>
        <button id="menuButton" class="menuButton">Main Menu</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const GameConfig = {
        soundEnabled: true,
        speechEnabled: true,
        quoteInterval: 20,
        pickupInterval: 15,
        gravity: -20,
        jumpForce: 15,
        fieldSize: 64,
        renderDistance: 3,
        chunkSize: 16,
        terrainAmplitude: 30.0,
        correlationLength: 8.0
      };

      const NARRATIVE_QUOTES = [
        "You stuck your finger to a USB port and woke up in the Matrix.",
        "The cubes. They're getting closer.",
        "The cubes reminded you of Bob from accounting.",
        "What can a man do to get out of here?",
        "Yippie kai yay, Matrix cube!",
        "Is this real? Are we real? Are cubes real?",
        "The cubetrix never ends.",
        "You remember that time you deleted System32. Good times.",
        "The cubepocalypse is upon us!",
        "The cubes remind me of cubicle.",
        "These cubes are taking their geometry very seriously.",
        "I think I was a cube in my previous life.",
        "Surely the cubetrix has an ending.",
        "What if I am a cube myself.",
        "There are only so many cubes a man can take.",
        "This place reminds me of, never mind, it reminds me of nothing.",
        "The cubetrix smells kind of odd.",
        "At least Neo was living in a more realistic world.",
        "This simulation is lacking definition.",
        "Perhaps I should try to find a backdoor, there must be one.",
        "Is this a cube or am I dreaming.",
        "Look at those mountain tops, let's go chill there for a while, the cubes don't like them.",
        "In the digital world, everyone can hear you scream... in 8-bit."
      ];

      const ENEMY_DEATH_PHRASES = [
        "Enemy has fallen!",
        "Down goes the cube!",
        "Cube smashed!",
        "Boxes belong to recycling!",
        "I am sorry cube, but there is only infinite amount of space here!",
        "I did what I had to do!",
        "I hope you won't be back!",
        "Just give up already!",
        "Target neutralized!",
        "Cube destroyed!"
      ];

      const DEATH_PHRASES = [
        "Game over, man!",
        "Oh Johnny boy!",
        "Back to real world!",
        "Is reality any better?",
        "I have seen c beams glittering in the dark!",
        "It is time!",
        "Finally, a way out of cubetrix!",
        "Here comes the light!",
        "You met your end!",
        "System failure!",
        "Critical damage detected!"
      ];

      class AudioManager {
        constructor() {
          this.sounds = {};
          this.audioContext = null;
          this.masterGainNode = null;
          this.soundsLoaded = 0;
          this.soundsToLoad = 0;
          try {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioContext = new AudioContext();
            this.masterGainNode = this.audioContext.createGain();
            this.masterGainNode.connect(this.audioContext.destination);
          } catch(e) {
            console.warn('Web Audio API not supported:', e);
          }
        }
        async loadSound(name, url) {
          if (!this.audioContext) return Promise.resolve();
          this.soundsToLoad++;
          return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.responseType = 'arraybuffer';
            request.onload = () => {
              if (request.status === 200) {
                this.audioContext.decodeAudioData(
                  request.response,
                  (buffer) => {
                    this.sounds[name] = buffer;
                    this.soundsLoaded++;
                    console.log(`Loaded sound: ${name} (${this.soundsLoaded}/${this.soundsToLoad})`);
                    resolve();
                  },
                  (error) => {
                    console.warn(`Error decoding sound ${name}:`, error);
                    this.soundsLoaded++;
                    resolve();
                  }
                );
              } else {
                console.warn(`Failed to load sound ${name}: HTTP status ${request.status}`);
                this.soundsLoaded++;
                resolve();
              }
            };
            request.onerror = (e) => {
              console.warn(`Failed to load sound ${name}:`, e);
              this.soundsLoaded++;
              resolve();
            };
            request.send();
          });
        }
        playSound(name, options = {}) {
          if (!GameConfig.soundEnabled || !this.audioContext || !this.sounds[name]) {
            console.log(`Cannot play sound ${name}: ${!GameConfig.soundEnabled ? 'Sound disabled' : !this.audioContext ? 'No audio context' : 'Sound not loaded'}`);
            return { stop: () => {} };
          }
          try {
            console.log(`Playing sound: ${name}`);
            const source = this.audioContext.createBufferSource();
            source.buffer = this.sounds[name];
            const gainNode = this.audioContext.createGain();
            gainNode.gain.value = options.volume || 1;
            source.connect(gainNode);
            gainNode.connect(this.masterGainNode);
            if (options.loop) { source.loop = true; }
            if (this.audioContext.state === 'suspended') { this.audioContext.resume(); }
            source.start(0);
            return {
              source: source,
              stop: function() {
                try { source.stop(); } catch(e) { console.warn('Error stopping sound:', e); }
              }
            };
          } catch(e) {
            console.warn(`Failed to play sound ${name}:`, e);
            return { stop: () => {} };
          }
        }
      }

      function speak(text) {
        if (!GameConfig.speechEnabled) return;
        if ('speechSynthesis' in window) {
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 0.9;
          window.speechSynthesis.speak(utterance);
          const quoteElement = document.getElementById('quote');
          quoteElement.textContent = text;
          quoteElement.style.opacity = '1';
          setTimeout(() => { quoteElement.style.opacity = '0'; }, 5000);
        }
      }

      class ThinkingField {
        constructor(size = 64, correlation = GameConfig.correlationLength, amplitude = GameConfig.terrainAmplitude) {
          this.size = size;
          this.correlation = correlation;
          this.amplitude = amplitude;
          console.log(`Initializing terrain with amplitude: ${amplitude}`);
          this.field = this.generateField();
        }
        generateField() {
          const field = [];
          for (let x = 0; x < this.size; x++) {
            field[x] = [];
            for (let z = 0; z < this.size; z++) {
              field[x][z] = Math.random() * 2 - 1;
            }
          }
          const smoothedField = [];
          for (let x = 0; x < this.size; x++) {
            smoothedField[x] = [];
            for (let z = 0; z < this.size; z++) {
              let sum = 0;
              let count = 0;
              for (let dx = -Math.floor(this.correlation); dx <= Math.floor(this.correlation); dx++) {
                for (let dz = -Math.floor(this.correlation); dz <= Math.floor(this.correlation); dz++) {
                  const nx = (x + dx + this.size) % this.size;
                  const nz = (z + dz + this.size) % this.size;
                  const weight = Math.exp(-(dx*dx + dz*dz) / (2 * this.correlation * this.correlation));
                  sum += field[nx][nz] * weight;
                  count += weight;
                }
              }
              smoothedField[x][z] = (sum / count) * this.amplitude;
            }
          }
          return smoothedField;
        }
        getHeight(x, z) {
          x = Math.floor(x) % this.size;
          z = Math.floor(z) % this.size;
          if (x < 0) x += this.size;
          if (z < 0) z += this.size;
          return this.field[x][z];
        }
      }

      class CubeTrixGame {
        constructor() {
          this.canvas = document.getElementById('gameCanvas');
          this.scoreElement = document.getElementById('score');
          this.healthFill = document.getElementById('healthFill');
          this.armorFill = document.getElementById('armorFill');
          this.gameStarted = false;
          this.gamePaused = false;
          this.gameOver = false;
          this.score = 0;
          this.setupThreeJS();
          this.audioManager = new AudioManager();
          this.loadSounds();
          this.field = new ThinkingField(GameConfig.fieldSize);
          this.player = null;
          this.weapon = null;
          this.enemies = [];
          this.pickups = [];
          this.bullets = [];
          this.terrainChunks = {};
          this.enemySpawnTimer = 0;
          this.enemySpawnInterval = 3;
          this.quoteTimer = 0;
          this.pickupTimer = 0;
          this.keys = {};
          this.cameraPitch = 0;
          this.cameraYaw = 0;
          this.setupEventListeners();
          this.lastTime = 0;
          this.animate();
        }
        
        setupThreeJS() {
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x87CEEB);
          this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          this.camera.position.set(32, 10, 32);
          this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.shadowMap.enabled = true;
          this.scene.fog = new THREE.FogExp2(0x87CEEB, 0.01);
          const ambientLight = new THREE.AmbientLight(0x404040);
          this.scene.add(ambientLight);
          const sunLight = new THREE.DirectionalLight(0xffffff, 1);
          sunLight.position.set(50, 50, 50);
          sunLight.castShadow = true;
          this.scene.add(sunLight);
          sunLight.shadow.mapSize.width = 2048;
          sunLight.shadow.mapSize.height = 2048;
          sunLight.shadow.camera.near = 0.5;
          sunLight.shadow.camera.far = 500;
          sunLight.shadow.camera.left = -100;
          sunLight.shadow.camera.right = 100;
          sunLight.shadow.camera.top = 100;
          sunLight.shadow.camera.bottom = -100;
          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();
        }
        
        async loadSounds() {
          const soundFiles = [
            { name: 'start', filename: 'start.ogg' },
            { name: 'background', filename: 'game.ogg' },
            { name: 'shoot', filename: 'shoot.ogg' },
            { name: 'jump', filename: 'jump.ogg' },
            { name: 'death', filename: 'death.ogg' },
            { name: 'enemyDeath', filename: 'cubedeath.ogg' },
            { name: 'pickup', filename: 'nom.ogg' },
            { name: 'armor', filename: 'armor.ogg' },
            { name: 'step', filename: 'step.ogg' },
            { name: 'attack', filename: 'attack.ogg' }
          ];
          
          console.log("Starting to load sound files...");
          const possiblePaths = [
            (filename) => `./assets/${filename}`,
            (filename) => `../assets/${filename}`,
            (filename) => `./${filename}`,
            (filename) => `/assets/${filename}`,
            (filename) => `${filename}`
          ];
          
          for (const sound of soundFiles) {
            let loaded = false;
            for (const pathFn of possiblePaths) {
              if (!loaded) {
                const path = pathFn(sound.filename);
                console.log(`Trying to load ${sound.name} from ${path}`);
                try {
                  await this.audioManager.loadSound(sound.name, path);
                  if (this.audioManager.sounds[sound.name]) {
                    console.log(`Successfully loaded ${sound.name} from ${path}`);
                    loaded = true;
                  }
                } catch (e) {
                  console.warn(`Failed to load ${sound.name} from ${path}`);
                }
              }
            }
            if (!loaded) {
              console.warn(`Could not load sound: ${sound.name}`);
            }
          }
          
          console.log("Finished sound loading attempts");
        }
        
        setupEventListeners() {
          window.addEventListener('keydown', (e) => {
            if (e.key === "Escape") {
              if (this.gameStarted && !this.gameOver) {
                this.pauseGame();
                document.getElementById('mainMenu').style.display = 'block';
                if (this.backgroundMusic) { this.backgroundMusic.stop(); }
              }
            } else {
              this.keys[e.key.toLowerCase()] = true;
            }
          });
          window.addEventListener('keyup', (e) => this.keys[e.key.toLowerCase()] = false);
          
          this.canvas.addEventListener('mousedown', () => {
            if (this.gameStarted && !this.gamePaused && !this.gameOver) {
              this.keys['mouse1'] = true;
              if (document.pointerLockElement !== this.canvas) {
                this.canvas.requestPointerLock();
              }
            }
          });
          this.canvas.addEventListener('mouseup', () => {
            this.keys['mouse1'] = false;
          });
          document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === this.canvas) {
              this.rotateCamera(e.movementX, e.movementY);
            }
          });
          document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement !== this.canvas && this.gameStarted && !this.gameOver) {
              this.pauseGame();
            }
          });
          window.addEventListener('resize', () => this.onWindowResize());
          
          document.getElementById('startButton').addEventListener('click', () => this.startGame());
          document.getElementById('helpButton').addEventListener('click', () => {
            document.getElementById('helpMenu').style.display = 'block';
            document.getElementById('startButton').style.display = 'none';
            document.getElementById('helpButton').style.display = 'none';
            document.getElementById('soundButton').style.display = 'none';
            document.getElementById('speechButton').style.display = 'none';
          });
          document.getElementById('backButton').addEventListener('click', () => {
            document.getElementById('helpMenu').style.display = 'none';
            document.getElementById('startButton').style.display = 'block';
            document.getElementById('helpButton').style.display = 'block';
            document.getElementById('soundButton').style.display = 'block';
            document.getElementById('speechButton').style.display = 'block';
          });
          document.getElementById('soundButton').addEventListener('click', () => this.toggleSound());
          document.getElementById('speechButton').addEventListener('click', () => this.toggleSpeech());
          document.getElementById('restartButton').addEventListener('click', () => this.resetGame());
          document.getElementById('menuButton').addEventListener('click', () => {
            document.getElementById('gameOverMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';
            if (this.backgroundMusic) { this.backgroundMusic.stop(); }
          });
        }
        
        toggleSound() {
          GameConfig.soundEnabled = !GameConfig.soundEnabled;
          document.getElementById('soundButton').textContent = `Sound: ${GameConfig.soundEnabled ? 'ON' : 'OFF'}`;
        }
        
        toggleSpeech() {
          GameConfig.speechEnabled = !GameConfig.speechEnabled;
          document.getElementById('speechButton').textContent = `Speech: ${GameConfig.speechEnabled ? 'ON' : 'OFF'}`;
        }
        
        onWindowResize() {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        startGame() {
          if (this.backgroundMusic) {
            this.backgroundMusic.stop();
          }
          this.gameStarted = true;
          this.gamePaused = false;
          this.gameOver = false;
          document.getElementById('mainMenu').style.display = 'none';
          this.createPlayer();
          this.canvas.requestPointerLock();
          this.backgroundMusic = this.audioManager.playSound('background', { loop: true, volume: 0.5 });
          this.spawnInitialEnemies();
          speak("You put your finger in a USB socket and found yourself in CubeTrix.");
        }
        
        pauseGame() {
          if (!this.gameStarted || this.gameOver) return;
          this.gamePaused = true;
          document.getElementById('mainMenu').style.display = 'block';
          document.exitPointerLock();
        }
        
        resumeGame() {
          if (!this.gameStarted || this.gameOver) return;
          this.gamePaused = false;
          document.getElementById('mainMenu').style.display = 'none';
          this.canvas.requestPointerLock();
        }
        
        gameOverScreen() {
          this.gameOver = true;
          document.getElementById('gameOverMenu').style.display = 'block';
          document.getElementById('finalScore').textContent = this.score;
          document.exitPointerLock();
          if (this.backgroundMusic) { this.backgroundMusic.stop(); }
          this.audioManager.playSound('death', { volume: 1.0 });
          speak(DEATH_PHRASES[Math.floor(Math.random() * DEATH_PHRASES.length)]);
        }
        
        resetGame() {
          this.score = 0;
          this.updateScore();
          this.clearEntities();
          document.getElementById('gameOverMenu').style.display = 'none';
          this.startGame();
        }
        
        clearEntities() {
          for (const enemy of this.enemies) {
            this.scene.remove(enemy.mesh);
          }
          this.enemies = [];
          for (const pickup of this.pickups) {
            this.scene.remove(pickup.mesh);
          }
          this.pickups = [];
          for (const bullet of this.bullets) {
            this.scene.remove(bullet.mesh);
          }
          this.bullets = [];
          if (this.player && this.player.mesh) {
            this.scene.remove(this.player.mesh);
          }
          if (this.weapon && this.weapon.mesh) {
            this.scene.remove(this.weapon.mesh);
          }
        }
        
        createPlayer() {
          this.player = {
            position: new THREE.Vector3(32, 10, 32),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: new THREE.Euler(0, 0, 0),
            health: 100,
            maxHealth: 100,
            armor: 100,
            maxArmor: 100,
            isGrounded: false,
            height: 2,
            speed: 10,
            mesh: null
          };
          const geometry = new THREE.BoxGeometry(1, 2, 1);
          const material = new THREE.MeshLambertMaterial({ color: 0x39f });
          this.player.mesh = new THREE.Mesh(geometry, material);
          this.player.mesh.position.copy(this.player.position);
          this.player.mesh.castShadow = true;
          this.player.mesh.receiveShadow = true;
          this.scene.add(this.player.mesh);
          this.createWeapon();
          this.updateHealthDisplay();
        }
        
        createWeapon() {
          const weaponGroup = new THREE.Group();
          const barrelGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.6);
          const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
          const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
          barrel.position.set(0, 0, -0.3);
          weaponGroup.add(barrel);
          const gripGeometry = new THREE.BoxGeometry(0.08, 0.2, 0.1);
          const gripMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
          const grip = new THREE.Mesh(gripGeometry, gripMaterial);
          grip.position.set(0, -0.15, 0);
          weaponGroup.add(grip);
          const sightGeometry = new THREE.BoxGeometry(0.02, 0.05, 0.02);
          const sightMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
          const sight = new THREE.Mesh(sightGeometry, sightMaterial);
          sight.position.set(0, 0.08, -0.1);
          weaponGroup.add(sight);
          weaponGroup.position.set(0.3, -0.25, -0.5);
          this.weapon = { mesh: weaponGroup };
          this.camera.add(weaponGroup);
        }
        
        shoot() {
          if (!this.weapon) return;
          this.audioManager.playSound('shoot', { volume: 0.8 });
          const bulletDirection = new THREE.Vector3(0, 0, -1);
          bulletDirection.applyQuaternion(this.camera.quaternion);
          this.createBullet(this.camera.position.clone(), bulletDirection);
          const weaponKickback = { x: 0, y: 0, z: -0.1 };
          const originalPosition = { 
            x: this.weapon.mesh.position.x,
            y: this.weapon.mesh.position.y,
            z: this.weapon.mesh.position.z
          };
          this.weapon.mesh.position.z += weaponKickback.z;
          setTimeout(() => {
            if (this.weapon && this.weapon.mesh) {
              this.weapon.mesh.position.set(
                originalPosition.x,
                originalPosition.y,
                originalPosition.z
              );
            }
          }, 50);
        }
        
        createBullet(position, direction) {
          const geometry = new THREE.SphereGeometry(0.1, 8, 8);
          const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.copy(position);
          this.scene.add(mesh);
          const bullet = {
            mesh: mesh,
            direction: direction,
            speed: 50,
            lifetime: 2,
            damage: 25
          };
          this.bullets.push(bullet);
        }
        
        spawnInitialEnemies() {
          for (let i = 0; i < 8; i++) {
            this.spawnEnemy();
          }
        }
        
        spawnEnemy() {
          const minDistance = 15;
          const maxDistance = 30;
          const spawnDistance = minDistance + Math.random() * (maxDistance - minDistance);
          const angle = Math.random() * Math.PI * 2;
          const x = this.player.position.x + Math.cos(angle) * spawnDistance;
          const z = this.player.position.z + Math.sin(angle) * spawnDistance;
          const y = this.field.getHeight(x, z) + 20;
          const size = 1.5 + Math.random() * 2.5;
          const colors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xff00ff, 0x00ffff, 0xffa500];
          const color = colors[Math.floor(Math.random() * colors.length)];
          const geometry = new THREE.BoxGeometry(size, size * 2, size);
          const material = new THREE.MeshLambertMaterial({ color: color });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(x, y, z);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          this.scene.add(mesh);
          const enemy = {
            mesh: mesh,
            originalColor: color,
            health: 100,
            speed: 6,
            searchRadius: 25,
            attackRange: 5,
            attackCooldown: 1.5,
            attackTimer: 0,
            damage: 15 * (size / 1.5),
            velocity: new THREE.Vector3(0, 0, 0),
            isGrounded: false,
            size: size
          };
          this.enemies.push(enemy);
        }
        
        spawnPickup() {
          const x = this.player.position.x + (Math.random() * 40 - 20);
          const z = this.player.position.z + (Math.random() * 40 - 20);
          const y = this.field.getHeight(x, z) + 20;
          const isHealthPickup = Math.random() < 0.7;
          const geometry = isHealthPickup ? 
            new THREE.SphereGeometry(0.3, 8, 8) : 
            new THREE.BoxGeometry(0.3, 0.3, 0.3);
          const material = new THREE.MeshLambertMaterial({ 
            color: isHealthPickup ? 0x00ff00 : 0x00aaff,
            emissive: isHealthPickup ? 0x00ff00 : 0x00aaff,
            emissiveIntensity: 0.3
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(x, y, z);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          this.scene.add(mesh);
          const pickup = {
            mesh: mesh,
            type: isHealthPickup ? 'health' : 'armor',
            amount: 50,
            rotationSpeed: 2
          };
          this.pickups.push(pickup);
        }
        
        getColorFromHeight(height) {
          if (height < -10) {
            return new THREE.Color(0.2, 0.1, 0.05);
          } else if (height < -5) {
            return new THREE.Color(0.3, 0.2, 0.1);
          } else if (height < 0) {
            return new THREE.Color(0.6, 0.3, 0.2);
          } else if (height < 8) {
            return new THREE.Color(0.9, 0.8, 0.5);
          } else if (height < 16) {
            return new THREE.Color(0.2, 0.8, 0.2);
          } else if (height < 24) {
            return new THREE.Color(0.5, 0.5, 0.5);
          } else {
            return new THREE.Color(1, 1, 1);
          }
        }
        
        updateTerrain() {
          const playerChunkX = Math.floor(this.player.position.x / GameConfig.chunkSize);
          const playerChunkZ = Math.floor(this.player.position.z / GameConfig.chunkSize);
          for (let dx = -GameConfig.renderDistance; dx <= GameConfig.renderDistance; dx++) {
            for (let dz = -GameConfig.renderDistance; dz <= GameConfig.renderDistance; dz++) {
              const chunkX = playerChunkX + dx;
              const chunkZ = playerChunkZ + dz;
              const chunkKey = `${chunkX},${chunkZ}`;
              if (!this.terrainChunks[chunkKey]) {
                this.generateChunk(chunkX, chunkZ);
              }
            }
          }
          for (const chunkKey in this.terrainChunks) {
            const [x, z] = chunkKey.split(',').map(Number);
            if (Math.abs(x - playerChunkX) > GameConfig.renderDistance || 
                Math.abs(z - playerChunkZ) > GameConfig.renderDistance) {
              this.scene.remove(this.terrainChunks[chunkKey]);
              delete this.terrainChunks[chunkKey];
            }
          }
        }
        
        generateChunk(chunkX, chunkZ) {
          const chunkKey = `${chunkX},${chunkZ}`;
          if (this.terrainChunks[chunkKey]) return;
          const geometry = new THREE.BufferGeometry();
          const vertices = [];
          const indices = [];
          const colors = [];
          const uvs = [];
          for (let x = 0; x < GameConfig.chunkSize; x++) {
            for (let z = 0; z < GameConfig.chunkSize; z++) {
              const worldX = chunkX * GameConfig.chunkSize + x;
              const worldZ = chunkZ * GameConfig.chunkSize + z;
              const h1 = this.field.getHeight(worldX, worldZ);
              const h2 = this.field.getHeight(worldX + 1, worldZ);
              const h3 = this.field.getHeight(worldX, worldZ + 1);
              const h4 = this.field.getHeight(worldX + 1, worldZ + 1);
              const baseIndex = vertices.length / 3;
              vertices.push(x, h1, z);
              colors.push(...this.getColorFromHeight(h1).toArray());
              uvs.push(x / GameConfig.chunkSize, z / GameConfig.chunkSize);
              vertices.push(x + 1, h2, z);
              colors.push(...this.getColorFromHeight(h2).toArray());
              uvs.push((x + 1) / GameConfig.chunkSize, z / GameConfig.chunkSize);
              vertices.push(x, h3, z + 1);
              colors.push(...this.getColorFromHeight(h3).toArray());
              uvs.push(x / GameConfig.chunkSize, (z + 1) / GameConfig.chunkSize);
              vertices.push(x + 1, h4, z + 1);
              colors.push(...this.getColorFromHeight(h4).toArray());
              uvs.push((x + 1) / GameConfig.chunkSize, (z + 1) / GameConfig.chunkSize);
              indices.push(
                baseIndex, baseIndex + 1, baseIndex + 2,
                baseIndex + 1, baseIndex + 3, baseIndex + 2
              );
            }
          }
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
          geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
          geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
          geometry.setIndex(indices);
          geometry.computeVertexNormals();
          const material = new THREE.MeshLambertMaterial({ vertexColors: true, side: THREE.DoubleSide });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(chunkX * GameConfig.chunkSize, 0, chunkZ * GameConfig.chunkSize);
          mesh.receiveShadow = true;
          this.scene.add(mesh);
          this.terrainChunks[chunkKey] = mesh;
        }
        
        updatePlayer(deltaTime) {
          if (!this.player) return;
          if (!this.player.isGrounded) {
            this.player.velocity.y += GameConfig.gravity * deltaTime;
          }
          this.player.position.y += this.player.velocity.y * deltaTime;
          const groundHeight = this.field.getHeight(this.player.position.x, this.player.position.z) + 1;
          if (this.player.position.y <= groundHeight) {
            this.player.position.y = groundHeight;
            this.player.velocity.y = 0;
            this.player.isGrounded = true;
          } else {
            this.player.isGrounded = false;
          }
          if (document.pointerLockElement === this.canvas) {
            let moveDirection = new THREE.Vector3(0, 0, 0);
            if (this.keys['w']) moveDirection.z -= 1;
            if (this.keys['s']) moveDirection.z += 1;
            if (this.keys['a']) moveDirection.x -= 1;
            if (this.keys['d']) moveDirection.x += 1;
            if (moveDirection.length() > 0) {
              moveDirection.normalize();
              const forward = new THREE.Vector3(0, 0, -1);
              forward.applyQuaternion(this.camera.quaternion);
              forward.y = 0;
              forward.normalize();
              const right = new THREE.Vector3(1, 0, 0);
              right.applyQuaternion(this.camera.quaternion);
              right.y = 0;
              right.normalize();
              const movement = new THREE.Vector3().addScaledVector(forward, -moveDirection.z).addScaledVector(right, moveDirection.x);
              let moveSpeed = this.player.speed;
              if (this.keys['shift']) moveSpeed *= 2;
              this.player.position.add(movement.multiplyScalar(moveSpeed * deltaTime));
            }
            if (this.keys[' '] && this.player.isGrounded) {
              this.player.velocity.y = GameConfig.jumpForce;
              this.player.isGrounded = false;
              this.audioManager.playSound('jump', { volume: 0.8 });
            }
          }
          this.player.mesh.position.copy(this.player.position);
          this.camera.position.set(this.player.position.x, this.player.position.y + this.player.height * 0.8, this.player.position.z);
        }
        
        updateEnemies(deltaTime) {
          for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];
            if (!enemy.isGrounded) {
              enemy.velocity.y += GameConfig.gravity * deltaTime;
              enemy.mesh.position.y += enemy.velocity.y * deltaTime;
            }
            const groundHeight = this.field.getHeight(enemy.mesh.position.x, enemy.mesh.position.z) + 1;
            if (enemy.mesh.position.y <= groundHeight) {
              enemy.mesh.position.y = groundHeight;
              enemy.velocity.y = 0;
              enemy.isGrounded = true;
            } else {
              enemy.isGrounded = false;
            }
            const terrainColor = this.getColorFromHeight(groundHeight - 1);
            if (terrainColor.r === 1 && terrainColor.g === 1 && terrainColor.b === 1) {
              continue;
            }
            const distanceVec = new THREE.Vector3().subVectors(this.player.position, enemy.mesh.position);
            const distance = distanceVec.length();
            if (distance < enemy.searchRadius) {
              this.raycaster.set(enemy.mesh.position, distanceVec.clone().normalize());
              const intersects = this.raycaster.intersectObjects(Object.values(this.terrainChunks), false);
              if (intersects.length === 0 || intersects[0].distance > distance) {
                if (enemy.isGrounded) {
                  const direction = distanceVec.clone().normalize();
                  direction.y = 0;
                  enemy.mesh.position.add(direction.multiplyScalar(enemy.speed * deltaTime));
                  enemy.mesh.lookAt(this.player.position.x, enemy.mesh.position.y, this.player.position.z);
                }
                if (distance < enemy.attackRange) {
                  enemy.attackTimer -= deltaTime;
                  if (enemy.attackTimer <= 0) {
                    this.damagePlayer(enemy.damage);
                    enemy.attackTimer = enemy.attackCooldown;
                  }
                }
              }
            }
            for (let j = 0; j < this.enemies.length; j++) {
              if (i !== j) {
                const otherEnemy = this.enemies[j];
                const repelDist = new THREE.Vector3().subVectors(enemy.mesh.position, otherEnemy.mesh.position).length();
                if (repelDist < 2) {
                  const repelDir = new THREE.Vector3().subVectors(enemy.mesh.position, otherEnemy.mesh.position).normalize();
                  enemy.mesh.position.add(repelDir.multiplyScalar(2 * deltaTime));
                }
              }
            }
            if (distance > 50) {
              this.scene.remove(enemy.mesh);
              this.enemies.splice(i, 1);
            }
          }
        }
        
        updateBullets(deltaTime) {
          for (let i = this.bullets.length - 1; i >= 0; i--) {
            const bullet = this.bullets[i];
            bullet.lifetime -= deltaTime;
            if (bullet.lifetime <= 0) {
              this.scene.remove(bullet.mesh);
              this.bullets.splice(i, 1);
              continue;
            }
            const moveAmount = bullet.speed * deltaTime;
            const newPosition = bullet.mesh.position.clone().add(bullet.direction.clone().multiplyScalar(moveAmount));
            this.raycaster.set(bullet.mesh.position, bullet.direction, 0, moveAmount);
            const terrainIntersects = this.raycaster.intersectObjects(Object.values(this.terrainChunks), false);
            const enemyMeshes = this.enemies.map(e => e.mesh);
            const enemyIntersects = this.raycaster.intersectObjects(enemyMeshes, false);
            const pickupMeshes = this.pickups.map(p => p.mesh);
            const pickupIntersects = this.raycaster.intersectObjects(pickupMeshes, false);
            const allIntersects = [...terrainIntersects, ...enemyIntersects, ...pickupIntersects].sort((a, b) => a.distance - b.distance);
            if (allIntersects.length > 0) {
              const hit = allIntersects[0];
              const enemyIndex = enemyMeshes.indexOf(hit.object);
              if (enemyIndex !== -1) {
                this.damageEnemy(this.enemies[enemyIndex], bullet.damage);
              }
              const pickupIndex = pickupMeshes.indexOf(hit.object);
              if (pickupIndex !== -1) {
                this.collectPickup(this.pickups[pickupIndex]);
              }
              this.scene.remove(bullet.mesh);
              this.bullets.splice(i, 1);
            } else {
              bullet.mesh.position.copy(newPosition);
            }
          }
        }
        
        updatePickups(deltaTime) {
          for (let i = this.pickups.length - 1; i >= 0; i--) {
            const pickup = this.pickups[i];
            pickup.mesh.rotation.y += pickup.rotationSpeed * deltaTime;
            const distance = new THREE.Vector3().subVectors(this.player.position, pickup.mesh.position).length();
            if (distance < 1.5) {
              this.collectPickup(pickup);
            }
          }
        }
        
        collectPickup(pickup) {
          if (pickup.type === 'health') {
            this.player.health = Math.min(this.player.maxHealth, this.player.health + pickup.amount);
          } else {
            this.player.armor = Math.min(this.player.maxArmor, this.player.armor + pickup.amount);
          }
          this.updateHealthDisplay();
          this.audioManager.playSound('pickup', { volume: 1.0 });
          const index = this.pickups.indexOf(pickup);
          if (index !== -1) {
            this.scene.remove(pickup.mesh);
            this.pickups.splice(index, 1);
          }
        }
        
        damageEnemy(enemy, amount) {
          enemy.health -= amount;
          const healthRatio = enemy.health / 100;
          const newColor = new THREE.Color().lerpColors(new THREE.Color(0xffffff), new THREE.Color(enemy.originalColor), healthRatio);
          enemy.mesh.material.color.copy(newColor);
          if (enemy.health <= 0) {
            this.killEnemy(enemy);
          }
        }
        
        killEnemy(enemy) {
          this.audioManager.playSound('enemyDeath', { volume: 0.8 });
          speak(ENEMY_DEATH_PHRASES[Math.floor(Math.random() * ENEMY_DEATH_PHRASES.length)]);
          this.score += 50;
          this.updateScore();
          if (Math.random() < 0.3) {
            const pickup = {
              mesh: new THREE.Mesh(
                Math.random() < 0.7 ?
                  new THREE.SphereGeometry(0.3, 8, 8) :
                  new THREE.BoxGeometry(0.3, 0.3, 0.3),
                new THREE.MeshLambertMaterial({ color: Math.random() < 0.7 ? 0x00ff00 : 0x00aaff, emissive: Math.random() < 0.7 ? 0x00ff00 : 0x00aaff, emissiveIntensity: 0.3 })
              ),
              type: Math.random() < 0.7 ? 'health' : 'armor',
              amount: 50,
              rotationSpeed: 2
            };
            pickup.mesh.position.copy(enemy.mesh.position);
            this.scene.add(pickup.mesh);
            this.pickups.push(pickup);
          }
          const index = this.enemies.indexOf(enemy);
          if (index !== -1) {
            this.scene.remove(enemy.mesh);
            this.enemies.splice(index, 1);
          }
        }
        
        damagePlayer(amount) {
          amount *= 0.4;
          if (this.player.armor > 0) {
            const armorDamage = Math.min(this.player.armor, amount * 0.7);
            this.player.armor = Math.max(0, this.player.armor - armorDamage);
            amount = Math.max(0, amount - armorDamage);
          }
          this.player.health = Math.max(0, this.player.health - amount);
          this.updateHealthDisplay();
          if (this.player.health <= 0) {
            this.gameOverScreen();
          }
        }
        
        updateHealthDisplay() {
          this.healthFill.style.width = `${(this.player.health / this.player.maxHealth) * 100}%`;
          this.armorFill.style.width = `${(this.player.armor / this.player.maxArmor) * 100}%`;
        }
        
        updateScore() {
          this.scoreElement.textContent = `Score: ${this.score}`;
        }
        
        rotateCamera(deltaX, deltaY) {
          const sensitivity = 0.005;
          this.cameraYaw -= deltaX * sensitivity;
          this.cameraPitch -= deltaY * sensitivity;
          this.cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraPitch));
          this.camera.rotation.set(this.cameraPitch, this.cameraYaw, 0, 'YXZ');
        }
        
        update(deltaTime) {
          if (!this.gameStarted || this.gamePaused || this.gameOver) return;
          this.updateTerrain();
          this.updatePlayer(deltaTime);
          this.updateEnemies(deltaTime);
          this.updateBullets(deltaTime);
          this.updatePickups(deltaTime);
          if (this.keys['mouse1']) {
            this.shoot();
          }
          this.enemySpawnTimer += deltaTime;
          if (this.enemySpawnTimer >= this.enemySpawnInterval) {
            this.enemySpawnTimer = 0;
            this.spawnEnemy();
          }
          this.pickupTimer += deltaTime;
          if (this.pickupTimer >= GameConfig.pickupInterval) {
            this.pickupTimer = 0;
            this.spawnPickup();
          }
          this.quoteTimer += deltaTime;
          if (this.quoteTimer >= GameConfig.quoteInterval) {
            this.quoteTimer = 0;
            speak(NARRATIVE_QUOTES[Math.floor(Math.random() * NARRATIVE_QUOTES.length)]);
          }
        }
        
        animate(time) {
          requestAnimationFrame((t) => this.animate(t));
          const deltaTime = (time - this.lastTime) / 1000;
          this.lastTime = time;
          const clampedDelta = Math.min(deltaTime, 0.1);
          this.update(clampedDelta);
          this.renderer.render(this.scene, this.camera);
        }
      }
      
      window.addEventListener('load', () => {
        console.log("Window loaded, initializing game...");
        const game = new CubeTrixGame();
      });
    });
  </script>
</body>
</html>
